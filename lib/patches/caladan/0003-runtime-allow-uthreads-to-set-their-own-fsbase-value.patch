From af16c541122d083fb258f6fad678ec04fbaac119 Mon Sep 17 00:00:00 2001
From: Josh Fried <joshuafried@gmail.com>
Date: Thu, 8 Dec 2022 15:05:23 -0500
Subject: [PATCH 03/16] runtime: allow uthreads to set their own fsbase values

---
 build/shared.mk      |  2 +-
 inc/runtime/thread.h | 14 ++++++++++++--
 runtime/defs.h       | 14 ++++++++------
 runtime/sched.c      | 37 ++++++++++++++++++++++++++++---------
 runtime/switch.S     | 17 +++++++++++++++++
 5 files changed, 66 insertions(+), 18 deletions(-)

diff --git a/build/shared.mk b/build/shared.mk
index 1e087d8..1d5bc4e 100644
--- a/build/shared.mk
+++ b/build/shared.mk
@@ -9,7 +9,7 @@ include $(ROOT_PATH)/build/config
 
 # shared toolchain definitions
 INC = -I$(ROOT_PATH)/inc
-FLAGS  = -g -Wall -D_GNU_SOURCE $(INC)
+FLAGS  = -g -Wall -D_GNU_SOURCE $(INC) -mfsgsbase
 LDFLAGS = -T $(ROOT_PATH)/base/base.ld
 LD      = gcc
 CC      = gcc
diff --git a/inc/runtime/thread.h b/inc/runtime/thread.h
index d71d30f..67dcceb 100644
--- a/inc/runtime/thread.h
+++ b/inc/runtime/thread.h
@@ -26,9 +26,13 @@ extern void thread_ready(thread_t *thread);
 extern void thread_ready_head(thread_t *thread);
 extern thread_t *thread_create(thread_fn_t fn, void *arg);
 extern thread_t *thread_create_with_buf(thread_fn_t fn, void **buf, size_t len);
+extern void __set_uthread_specific(thread_t *th, uint64_t val);
+extern uint64_t __get_uthread_specific(thread_t *th);
+extern void set_fsbase(thread_t *th, uint64_t fsbase);
 
 DECLARE_PERTHREAD(thread_t *, __self);
 DECLARE_PERTHREAD(unsigned int, kthread_idx);
+DECLARE_PERTHREAD(uint64_t, runtime_fsbase);
 
 static inline unsigned int get_current_affinity(void)
 {
@@ -43,9 +47,15 @@ inline thread_t *thread_self(void)
 	return perthread_read_stable(__self);
 }
 
+static inline uint64_t get_uthread_specific(void)
+{
+    return __get_uthread_specific(thread_self());
+}
 
-extern uint64_t get_uthread_specific(void);
-extern void set_uthread_specific(uint64_t val);
+static inline void set_uthread_specific(uint64_t val)
+{
+    __set_uthread_specific(thread_self(), val);
+}
 
 
 /*
diff --git a/runtime/defs.h b/runtime/defs.h
index 3dbb57d..295fce9 100644
--- a/runtime/defs.h
+++ b/runtime/defs.h
@@ -72,6 +72,7 @@ struct thread_tf {
 	uint64_t rax;	/* holds return value */
 	uint64_t rip;	/* instruction pointer */
 	uint64_t rsp;	/* stack pointer */
+	uint64_t fsbase; /* holds %fs */
 };
 
 #define ARG0(tf)        ((tf)->rdi)
@@ -93,6 +94,7 @@ struct thread {
 	struct list_node	link;
 	struct stack		*stack;
 	unsigned int		main_thread:1;
+	unsigned int		has_fsbase:1;
 	unsigned int		thread_ready;
 	unsigned int		thread_running;
 	unsigned int		last_cpu;
@@ -113,8 +115,8 @@ extern void __jmp_thread_direct(struct thread_tf *oldtf,
 				struct thread_tf *newtf,
 				unsigned int *thread_running);
 extern void __jmp_runtime(struct thread_tf *tf, runtime_fn_t fn,
-			  void *stack);
-extern void __jmp_runtime_nosave(runtime_fn_t fn, void *stack) __noreturn;
+			  void *stack, uint64_t fsbase);
+extern void __jmp_runtime_nosave(runtime_fn_t fn, void *stack, uint64_t fsbase) __noreturn;
 
 
 /*
@@ -140,10 +142,10 @@ DECLARE_PERTHREAD(struct tcache_perthread, stack_pt);
  */
 static inline struct stack *stack_alloc(void)
 {
-	void *s = tcache_alloc(perthread_ptr(stack_pt));
-	if (unlikely(!s))
+	void *p = tcache_alloc(perthread_ptr(stack_pt));
+	if (unlikely(!p))
 		return NULL;
-	return container_of(s, struct stack, usable);
+	return container_of((uintptr_t (*)[STACK_PTR_SIZE])p, struct stack, usable);
 }
 
 /**
@@ -258,7 +260,7 @@ static inline bool hardware_q_pending(struct hardware_q *q)
 	tail = ACCESS_ONCE(*q->consumer_idx);
 	idx = tail & (q->nr_descriptors - 1);
 	parity = !!(tail & q->nr_descriptors);
-	addr = q->descriptor_table +
+	addr = (unsigned char *)q->descriptor_table +
 		     (idx << q->descriptor_log_size) + q->parity_byte_offset;
 	hd_parity = !!(ACCESS_ONCE(*addr) & q->parity_bit_mask);
 
diff --git a/runtime/sched.c b/runtime/sched.c
index 48c74c0..7a9f903 100644
--- a/runtime/sched.c
+++ b/runtime/sched.c
@@ -3,6 +3,7 @@
  */
 
 #include <sched.h>
+#include <immintrin.h>
 
 #include <base/stddef.h>
 #include <base/lock.h>
@@ -21,7 +22,7 @@
 DEFINE_PERTHREAD(thread_t *, __self);
 /* a pointer to the top of the per-kthread (TLS) runtime stack */
 static DEFINE_PERTHREAD(void *, runtime_stack);
-
+DEFINE_PERTHREAD(uint64_t, runtime_fsbase);
 /* Flag to prevent watchdog from running */
 bool disable_watchdog;
 
@@ -43,16 +44,23 @@ static DEFINE_PERTHREAD(uint64_t, last_tsc);
  */
 thread_t *thread_self(void);
 
-uint64_t get_uthread_specific(void)
+uint64_t __get_uthread_specific(thread_t *th)
+{
+	return th->tlsvar;
+}
+
+void __set_uthread_specific(thread_t *th, uint64_t val)
 {
-	BUG_ON(!perthread_read_stable(__self));
-	return (perthread_read_stable(__self))->tlsvar;
+	th->tlsvar = val;
 }
 
-void set_uthread_specific(uint64_t val)
+void set_fsbase(thread_t *th, uint64_t fsbase)
 {
-	BUG_ON(!perthread_read_stable(__self));
-	(perthread_read_stable(__self))->tlsvar = val;
+	th->tf.fsbase = fsbase;
+	barrier();
+	th->has_fsbase = true;
+	if (thread_self() == th)
+		_writefsbase_u64(fsbase);
 }
 
 /**
@@ -85,6 +93,10 @@ static __noreturn void jmp_thread(thread_t *th)
 		while (load_acquire(&th->thread_running))
 			cpu_relax();
 	}
+
+	if (!th->has_fsbase)
+		th->tf.fsbase = perthread_read(runtime_fsbase);
+
 	th->thread_running = true;
 	__jmp_thread(&th->tf);
 }
@@ -109,6 +121,10 @@ static void jmp_thread_direct(thread_t *oldth, thread_t *newth)
 		while (load_acquire(&newth->thread_running))
 			cpu_relax();
 	}
+
+	if (!newth->has_fsbase)
+		newth->tf.fsbase = perthread_read(runtime_fsbase);
+
 	newth->thread_running = true;
 	__jmp_thread_direct(&oldth->tf, &newth->tf, &oldth->thread_running);
 }
@@ -128,7 +144,7 @@ static void jmp_runtime(runtime_fn_t fn)
 	assert_preempt_disabled();
 	assert(thread_self() != NULL);
 
-	__jmp_runtime(&thread_self()->tf, fn, perthread_read(runtime_stack));
+	__jmp_runtime(&thread_self()->tf, fn, perthread_read(runtime_stack), perthread_read(runtime_fsbase));
 }
 
 /**
@@ -140,7 +156,7 @@ static __noreturn void jmp_runtime_nosave(runtime_fn_t fn)
 {
 	assert_preempt_disabled();
 
-	__jmp_runtime_nosave(fn, perthread_read(runtime_stack));
+	__jmp_runtime_nosave(fn, perthread_read(runtime_stack), perthread_read(runtime_fsbase));
 }
 
 static void drain_overflow(struct kthread *l)
@@ -799,8 +815,10 @@ static __always_inline thread_t *__thread_create(void)
 
 	th->stack = s;
 	th->main_thread = false;
+	th->has_fsbase = false;
 	th->thread_ready = false;
 	th->thread_running = false;
+	th->tlsvar = 0;
 
 	return th;
 }
@@ -976,6 +994,7 @@ int sched_init_thread(void)
 		return -ENOMEM;
 
 	perthread_store(runtime_stack, (void *)stack_init_to_rsp(s, runtime_top_of_stack));
+	perthread_store(runtime_fsbase, _readfsbase_u64());
 
 	return 0;
 }
diff --git a/runtime/switch.S b/runtime/switch.S
index fbca860..1ccab11 100644
--- a/runtime/switch.S
+++ b/runtime/switch.S
@@ -36,6 +36,7 @@
 #define RAX	(112)	/* return code */
 #define RIP	(120)	/* instruction pointer */
 #define RSP	(128)	/* stack pointer */
+#define FSBASE	(136)	/* fsbase */
 
 /**
  * __jmp_thread - executes a thread from the runtime
@@ -61,6 +62,10 @@ __jmp_thread:
 	movq    R14(%rdi), %r14
 	movq    R15(%rdi), %r15
 
+	/* restore FS base */
+	movq	FSBASE(%rdi), %r8
+	wrfsbase	%r8
+
 	/* set first argument (in case new thread) */
 	movq    RDI(%rdi), %rdi /* ARG0 */
 
@@ -128,6 +133,10 @@ __jmp_thread_direct:
 	movq    R14(%rsi), %r14
 	movq    R15(%rsi), %r15
 
+	/* restore FS */
+	movq	FSBASE(%rsi), %rdi
+	wrfsbase	%rdi
+
 	/* set first argument (in case new thread) */
 	movq    RDI(%rsi), %rdi /* ARG0 */
 
@@ -158,6 +167,7 @@ __jmp_thread_direct:
  * @tf: the struct thread_tf to save state (%rdi)
  * @fn: the function pointer to call (%rsi)
  * @stack: the start of the runtime stack (%rdx)
+ * @fsbase: the fs base register (%rcx)
  *
  * This low-level variant isn't intended to be called directly.
  * Must be called with preemption disabled.
@@ -181,6 +191,9 @@ __jmp_runtime:
 	leaq    8(%rsp), %r8
 	movq    %r8, RSP(%rdi)
 
+	/* restore fs */
+	wrfsbase %rcx
+
 	/* jump into runtime function */
 	movq    %rdx, %rsp
 
@@ -192,6 +205,7 @@ __jmp_runtime:
  *			  current stack frame
  * @fn: the function pointer to call (%rdi)
  * @stack: the start of the runtime stack (%rsi)
+ * @fsbase: the fs base register (%rdx)
  *
  * This low-level variant isn't intended to be called directly.
  * Must be called with preemption disabled.
@@ -206,5 +220,8 @@ __jmp_runtime_nosave:
 	movq    %rsi, %rsp
 	movq	%rdi, %rsi
 
+	/* restore fs */
+	wrfsbase %rdx
+
 	/* jump into runtime code */
 	jmpq    *%rsi
-- 
2.37.2

