From 41cf60d428f1019de3fd54a811c983e3fbbf8d30 Mon Sep 17 00:00:00 2001
From: Josh Fried <joshuafried@gmail.com>
Date: Tue, 1 Oct 2024 22:00:23 -0400
Subject: [PATCH 43/43] net updates

---
 inc/runtime/tcp.h |  32 ++++++++--
 inc/runtime/udp.h |  22 +++++--
 runtime/net/tcp.c | 152 +++++++++++++++++++++++++++-------------------
 runtime/net/udp.c |  16 ++---
 runtime/stat.c    |   2 +-
 5 files changed, 142 insertions(+), 82 deletions(-)

diff --git a/inc/runtime/tcp.h b/inc/runtime/tcp.h
index 432edef..8cc2541 100644
--- a/inc/runtime/tcp.h
+++ b/inc/runtime/tcp.h
@@ -35,12 +35,32 @@ extern int tcpq_backlog(tcpqueue_t *q);
 extern struct netaddr tcp_local_addr(tcpconn_t *c);
 extern struct netaddr tcp_remote_addr(tcpconn_t *c);
 extern int tcp_get_status(tcpconn_t *c);
-extern ssize_t tcp_read(tcpconn_t *c, void *buf, size_t len);
-extern ssize_t tcp_write(tcpconn_t *c, const void *buf, size_t len);
-extern ssize_t tcp_readv(tcpconn_t *c, const struct iovec *iov, int iovcnt);
-extern ssize_t tcp_readv_peek(tcpconn_t *c, const struct iovec *iov, int iovcnt);
-extern ssize_t tcp_read_peek(tcpconn_t *c, void *buf, size_t len);
-extern ssize_t tcp_writev(tcpconn_t *c, const struct iovec *iov, int iovcnt);
+
+extern ssize_t tcp_read2(tcpconn_t *c, void *buf, size_t len, bool peek, bool nonblocking);
+extern ssize_t tcp_write2(tcpconn_t *c, const void *buf, size_t len, bool nonblocking);
+extern ssize_t tcp_readv2(tcpconn_t *c, const struct iovec *iov, int iovcnt, bool peek, bool nonblocking);
+extern ssize_t tcp_writev2(tcpconn_t *c, const struct iovec *iov, int iovcnt, bool nonblocking);
+
+static inline ssize_t tcp_read(tcpconn_t *c, void *buf, size_t len)
+{
+	return tcp_read2(c, buf, len, false, false);
+}
+
+static inline ssize_t tcp_write(tcpconn_t *c, const void *buf, size_t len)
+{
+	return tcp_write2(c, buf, len, false);
+}
+
+static inline ssize_t tcp_readv(tcpconn_t *c, const struct iovec *iov, int iovcnt)
+{
+	return tcp_readv2(c, iov, iovcnt, false, false);
+}
+
+static inline ssize_t tcp_writev(tcpconn_t *c, const struct iovec *iov, int iovcnt)
+{
+	return tcp_writev2(c, iov, iovcnt, false);
+}
+
 extern int tcp_shutdown(tcpconn_t *c, int how);
 extern void tcp_abort(tcpconn_t *c);
 extern void tcp_close(tcpconn_t *c);
diff --git a/inc/runtime/udp.h b/inc/runtime/udp.h
index 7702fbe..bde1aba 100644
--- a/inc/runtime/udp.h
+++ b/inc/runtime/udp.h
@@ -40,10 +40,24 @@ extern int udp_listen(struct netaddr laddr, udpconn_t **c_out);
 extern struct netaddr udp_local_addr(udpconn_t *c);
 extern struct netaddr udp_remote_addr(udpconn_t *c);
 extern int udp_set_buffers(udpconn_t *c, int read_mbufs, int write_mbufs);
-extern ssize_t udp_read_from(udpconn_t *c, void *buf, size_t len,
-			     struct netaddr *raddr, bool peek);
-extern ssize_t udp_write_to(udpconn_t *c, const void *buf, size_t len,
-			    const struct netaddr *raddr);
+
+extern ssize_t udp_read_from2(udpconn_t *c, void *buf, size_t len,
+			     struct netaddr *raddr, bool peek, bool nonblocking);
+extern ssize_t udp_write_to2(udpconn_t *c, const void *buf, size_t len,
+			    const struct netaddr *raddr, bool nonblocking);
+
+static inline ssize_t udp_read_from(udpconn_t *c, void *buf, size_t len,
+			     struct netaddr *raddr)
+{
+	return udp_read_from2(c, buf, len, raddr, false, false);
+}
+
+static inline ssize_t udp_write_to(udpconn_t *c, const void *buf, size_t len,
+			    const struct netaddr *raddr)
+{
+	return udp_write_to2(c, buf, len, raddr, false);
+}
+
 extern ssize_t udp_read(udpconn_t *c, void *buf, size_t len);
 extern ssize_t udp_write(udpconn_t *c, const void *buf, size_t len);
 extern void udp_shutdown(udpconn_t *c);
diff --git a/runtime/net/tcp.c b/runtime/net/tcp.c
index 072a143..e9b419c 100644
--- a/runtime/net/tcp.c
+++ b/runtime/net/tcp.c
@@ -862,11 +862,21 @@ struct netaddr tcp_remote_addr(tcpconn_t *c)
 	return c->e.raddr;
 }
 
-static int tcp_wait_rx(tcpconn_t *c) {
+/**
+ * tcp_wait_rx - blocks until there is an actionable event.
+ * @c: the TCP connection
+ *
+ * Returns 1 if there is data ready. Returns 0 or a negative number
+ * if there is an error.
+ */
+static int tcp_wait_rx(tcpconn_t *c, bool nonblocking)
+{
 	int ret;
+	assert(spin_lock_held(&c->lock));
+
 	/* block until there is an actionable event */
 	while (!c->rx_closed && (c->rx_exclusive || list_empty(&c->rxq))) {
-		if (c->nonblocking) {
+		if (nonblocking) {
 			spin_unlock_np(&c->lock);
 			return -EAGAIN;
 		}
@@ -877,7 +887,12 @@ static int tcp_wait_rx(tcpconn_t *c) {
 		}
 	}
 
-	return 0;
+	if (c->rx_closed) {
+		spin_unlock_np(&c->lock);
+		return -c->err;
+	}
+
+	return 1;
 }
 
 /**
@@ -885,32 +900,31 @@ static int tcp_wait_rx(tcpconn_t *c) {
  * @c: the TCP connection
  * @buf: a buffer to store the read data
  * @len: the length of @buf
+ * @nonblocking: true if this call should not block
  *
  * Returns the number of bytes read, 0 if the connection is closed, or < 0
  * if an error occurred.
  */
-ssize_t tcp_read_peek(tcpconn_t *c, void *buf, size_t len) {
+static ssize_t tcp_read_peek(tcpconn_t *c, void *buf, size_t len,
+	                         bool nonblocking)
+{
 	int ret;
 	struct mbuf *m;
 	size_t tocopy, readlen = 0;
 
 	spin_lock_np(&c->lock);
 
-	if(unlikely(ret = tcp_wait_rx(c))) return ret;
-
-	/* is the socket closed? */
-	if (c->rx_closed) {
-		spin_unlock_np(&c->lock);
-		return 0;
-	}
+	ret = tcp_wait_rx(c, c->nonblocking || nonblocking);
+	if (unlikely(ret <= 0))
+		return ret;
 
 	list_for_each(&c->rxq, m, link) {
-	tocopy = MIN(mbuf_length(m), len - readlen);
-	memcpy(buf + readlen, mbuf_data(m), tocopy);
-	readlen += tocopy;
+		tocopy = MIN(mbuf_length(m), len - readlen);
+		memcpy(buf + readlen, mbuf_data(m), tocopy);
+		readlen += tocopy;
 
-	if (len == readlen)
-		break;
+		if (len == readlen)
+			break;
 	}
 
 	spin_unlock_np(&c->lock);
@@ -929,43 +943,39 @@ static size_t iov_len(const struct iovec *iov, int iovcnt)
 }
 
 /**
- * tcp_readv_peek - reads vectorized data from a TCP connection without consuming the data.
+ * tcp_readv_peek - reads vectorized data from a TCP connection without
+ * consuming the data.
  * @c: the TCP connection
  * @iov: a pointer to the IO vector
  * @iovcnt: the number of vectors in @iov
+ * @nonblocking: true if this call should not block
  *
  * Returns the number of bytes read, 0 if the connection is closed, or < 0
  * if an error occurred.
  */
-ssize_t tcp_readv_peek(tcpconn_t *c, const struct iovec *iov,
-			     int iovcnt) {
+static ssize_t tcp_readv_peek(tcpconn_t *c, const struct iovec *iov,
+			     int iovcnt, bool nonblocking)
+{
 	int ret, i = 0;
 	struct mbuf *m;
 	const struct iovec *vp;
 	size_t tocopy, readlen = 0;
 	off_t mbuf_off = 0, iov_off = 0;
-	size_t len = iov_len(iov, iovcnt);
 
-	spin_lock_np(&c->lock);
+	assert(iovcnt > 0 && iov[0].iov_len > 0);
 
-	if(unlikely(ret = tcp_wait_rx(c))) return ret;
+	spin_lock_np(&c->lock);
 
-	/* is the socket closed? */
-	if (c->rx_closed) {
-		spin_unlock_np(&c->lock);
-		return 0;
-	}
+	ret = tcp_wait_rx(c, c->nonblocking || nonblocking);
+	if (unlikely(ret <= 0))
+		return ret;
 
 	m = list_top(&c->rxq, struct mbuf, link);
+	vp = &iov[0];
 
-	do {
-		vp = &iov[i];
-
-		tocopy = MIN(len - readlen,
-			MIN(vp->iov_len - iov_off,
-			mbuf_length(m) - mbuf_off));
-		memcpy((char *)vp->iov_base + iov_off,
-		mbuf_data(m) + mbuf_off, tocopy);
+	while (true) {
+		tocopy = MIN(vp->iov_len - iov_off, mbuf_length(m) - mbuf_off);
+		memcpy((char *)vp->iov_base + iov_off, mbuf_data(m) + mbuf_off, tocopy);
 
 		iov_off += tocopy;
 		mbuf_off += tocopy;
@@ -973,39 +983,37 @@ ssize_t tcp_readv_peek(tcpconn_t *c, const struct iovec *iov,
 
 		if (mbuf_off == mbuf_length(m)) {
 			m = list_next(&c->rxq, m, link);
+			if (m == NULL)
+				break;
 			mbuf_off = 0;
 		}
 
 		if (iov_off == vp->iov_len) {
+			if (++i == iovcnt)
+				break;
 			iov_off = 0;
-			i++;
+			vp = &iov[i];
 		}
-
-		assert(i <= iovcnt);
-	}  while ((len != readlen) && (m != NULL));
+	}
 
 	spin_unlock_np(&c->lock);
 	return readlen;
 }
 
 static ssize_t tcp_read_wait(tcpconn_t *c, size_t len,
-			     struct list_head *q, struct mbuf **mout)
+			     struct list_head *q, struct mbuf **mout, bool nonblocking)
 {
 	int ret;
 	struct mbuf *m;
-	size_t tocopy, readlen = 0;
+	size_t readlen = 0;
 	bool do_ack = false;
 
 	*mout = NULL;
 	spin_lock_np(&c->lock);
 
-	if(unlikely(ret = tcp_wait_rx(c))) return ret;
-
-	/* is the socket closed? */
-	if (c->rx_closed) {
-	  spin_unlock_np(&c->lock);
-	  return -c->err;
-	}
+	ret = tcp_wait_rx(c, nonblocking);
+	if (unlikely(ret <= 0))
+		return ret;
 
 	/* pop off the mbufs that will be read */
 	while (readlen < len) {
@@ -1063,25 +1071,30 @@ static void tcp_read_finish(tcpconn_t *c, struct mbuf *m)
 }
 
 /**
- * tcp_read - reads data from a TCP connection
+ * tcp_read2 - reads data from a TCP connection
  * @c: the TCP connection
  * @buf: a buffer to store the read data
  * @len: the length of @buf
+ * @nonblocking: true if this call should not block
  *
  * Returns the number of bytes read, 0 if the connection is closed, or < 0
  * if an error occurred.
  */
-ssize_t tcp_read(tcpconn_t *c, void *buf, size_t len)
+ssize_t tcp_read2(tcpconn_t *c, void *buf, size_t len, bool peek,
+	              bool nonblocking)
 {
 	char *pos = buf;
 	struct list_head q;
 	struct mbuf *m;
 	ssize_t ret;
 
+	if (peek)
+		return tcp_read_peek(c, buf, len, nonblocking);
+
 	list_head_init(&q);
 
 	/* wait for data to become available */
-	ret = tcp_read_wait(c, len, &q, &m);
+	ret = tcp_read_wait(c, len, &q, &m, c->nonblocking || nonblocking);
 
 	/* check if connection was closed */
 	if (ret <= 0)
@@ -1116,22 +1129,30 @@ ssize_t tcp_read(tcpconn_t *c, void *buf, size_t len)
  * @c: the TCP connection
  * @iov: a pointer to the IO vector
  * @iovcnt: the number of vectors in @iov
+ * @nonblocking: true if this call should not block
  *
  * Returns the number of bytes read, 0 if the connection is closed, or < 0
  * if an error occurred.
  */
-ssize_t tcp_readv(tcpconn_t *c, const struct iovec *iov, int iovcnt)
+ssize_t tcp_readv2(tcpconn_t *c, const struct iovec *iov, int iovcnt, bool peek,
+	               bool nonblocking)
 {
 	struct list_head q;
 	struct mbuf *m;
-	ssize_t len = iov_len(iov, iovcnt);
-	off_t offset = 0;
-	int i = 0;
+	ssize_t len;
+	off_t offset;
+	int i;
+
+	if (peek)
+		return tcp_readv_peek(c, iov, iovcnt, nonblocking);
 
 	list_head_init(&q);
+	offset = 0;
+	i = 0;
+	len = iov_len(iov, iovcnt);
 
 	/* wait for data to become available */
-	len = tcp_read_wait(c, len, &q, &m);
+	len = tcp_read_wait(c, len, &q, &m, c->nonblocking || nonblocking);
 
 	/* check if connection was closed */
 	if (len <= 0)
@@ -1188,7 +1209,7 @@ ssize_t tcp_readv(tcpconn_t *c, const struct iovec *iov, int iovcnt)
 	return len;
 }
 
-static int tcp_write_wait(tcpconn_t *c, size_t *winlen)
+static int tcp_write_wait(tcpconn_t *c, size_t *winlen, bool nonblocking)
 {
 	int ret;
 	spin_lock_np(&c->lock);
@@ -1203,7 +1224,7 @@ static int tcp_write_wait(tcpconn_t *c, size_t *winlen)
 			c->zero_wnd_ts = microtime();
 			tcp_timer_update(c);
 		}
-		if (c->nonblocking) {
+		if (nonblocking) {
 			spin_unlock_np(&c->lock);
 			return -EAGAIN;
 		}
@@ -1275,21 +1296,22 @@ static void tcp_write_finish(tcpconn_t *c)
 }
 
 /**
- * tcp_write - writes data to a TCP connection
+ * tcp_write2 - writes data to a TCP connection
  * @c: the TCP connection
  * @buf: a buffer from which to copy the data
  * @len: the length of the data
+ * @nonblocking: true if this call should not block
  *
  * Returns the number of bytes written (could be less than @len), or < 0
  * if there was a failure.
  */
-ssize_t tcp_write(tcpconn_t *c, const void *buf, size_t len)
+ssize_t tcp_write2(tcpconn_t *c, const void *buf, size_t len, bool nonblocking)
 {
 	size_t winlen;
 	ssize_t ret;
 
 	/* block until the data can be sent */
-	ret = tcp_write_wait(c, &winlen);
+	ret = tcp_write_wait(c, &winlen, c->nonblocking || nonblocking);
 	if (ret)
 		return ret;
 
@@ -1303,22 +1325,24 @@ ssize_t tcp_write(tcpconn_t *c, const void *buf, size_t len)
 }
 
 /**
- * tcp_writev - writes vectored data to a TCP connection
+ * tcp_writev2 - writes vectored data to a TCP connection
  * @c: the TCP connection
  * @iov: a pointer to the IO vector
  * @iovcnt: the number of vectors in @iov
+ * @nonblocking: true if this call should not block
  *
  * Returns the number of bytes written (could be less than requested), or < 0
  * if there was a failure.
  */
-ssize_t tcp_writev(tcpconn_t *c, const struct iovec *iov, int iovcnt)
+ssize_t tcp_writev2(tcpconn_t *c, const struct iovec *iov, int iovcnt,
+	                bool nonblocking)
 {
 	size_t winlen;
 	ssize_t sent = 0, ret;
 	int i;
 
 	/* block until the data can be sent */
-	ret = tcp_write_wait(c, &winlen);
+	ret = tcp_write_wait(c, &winlen, c->nonblocking || nonblocking);
 	if (ret)
 		return ret;
 
diff --git a/runtime/net/udp.c b/runtime/net/udp.c
index 12ab610..7cfab8c 100644
--- a/runtime/net/udp.c
+++ b/runtime/net/udp.c
@@ -320,17 +320,18 @@ int udp_set_buffers(udpconn_t *c, int read_mbufs, int write_mbufs)
  * Returns the number of bytes in the datagram, or @len if the datagram
  * is >= @len in size. If the socket has been shutdown, returns 0.
  */
-ssize_t udp_read_from(udpconn_t *c, void *buf, size_t len,
-                      struct netaddr *raddr, bool peek)
+ssize_t udp_read_from2(udpconn_t *c, void *buf, size_t len,
+                      struct netaddr *raddr, bool peek, bool nonblocking)
 {
 	ssize_t ret;
 	struct mbuf *m;
 
 	spin_lock_np(&c->inq_lock);
+	nonblocking |= c->nonblocking;
 
 	/* block until there is an actionable event */
 	while (mbufq_empty(&c->inq) && !c->inq_err && !c->shutdown) {
-		if (c->nonblocking) {
+		if (nonblocking) {
 			spin_unlock_np(&c->inq_lock);
 			return -EAGAIN;
 		}
@@ -419,8 +420,8 @@ static void udp_tx_release_mbuf(struct mbuf *m)
  * Returns the number of payload bytes sent in the datagram. If an error
  * occurs, returns < 0 to indicate the error code.
  */
-ssize_t udp_write_to(udpconn_t *c, const void *buf, size_t len,
-                     const struct netaddr *raddr)
+ssize_t udp_write_to2(udpconn_t *c, const void *buf, size_t len,
+                     const struct netaddr *raddr, bool nonblocking)
 {
 	struct netaddr addr;
 	ssize_t ret;
@@ -441,10 +442,11 @@ ssize_t udp_write_to(udpconn_t *c, const void *buf, size_t len,
 	}
 
 	spin_lock_np(&c->outq_lock);
+	nonblocking |= c->nonblocking;
 
 	/* block until there is an actionable event */
 	while (c->outq_len >= c->outq_cap && !c->shutdown) {
-		if (c->nonblocking) {
+		if (nonblocking) {
 			spin_unlock_np(&c->outq_lock);
 			return -EAGAIN;
 		}
@@ -503,7 +505,7 @@ ssize_t udp_write_to(udpconn_t *c, const void *buf, size_t len,
  */
 ssize_t udp_read(udpconn_t *c, void *buf, size_t len)
 {
-	return udp_read_from(c, buf, len, NULL, false);
+	return udp_read_from(c, buf, len, NULL);
 }
 
 /**
diff --git a/runtime/stat.c b/runtime/stat.c
index 917bc4a..abc273b 100644
--- a/runtime/stat.c
+++ b/runtime/stat.c
@@ -202,7 +202,7 @@ static void stat_worker_udp(void *arg)
 	}
 
 	while (true) {
-		ret = udp_read_from(c, buf, payload_size, &raddr, false);
+		ret = udp_read_from(c, buf, payload_size, &raddr);
 		if (ret < cmd_len)
 			continue;
 		if (strncmp(buf, "stat", cmd_len) != 0)
-- 
2.43.0

